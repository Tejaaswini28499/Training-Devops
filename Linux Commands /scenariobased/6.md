To check **which process is listening on a specific port** in Linux, you can use several commands. Here’s a clear breakdown:

---

### **1. Using `lsof`**

`lsof` lists open files, including network sockets.

```bash
sudo lsof -i :<port_number>
```

**Example:** Check which process is using port 8080:

```bash
sudo lsof -i :8080
```

**Output:**

```
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
java     1234 root   45u  IPv6 123456      0t0  TCP *:8080 (LISTEN)
```

* **PID** = 1234 → Process ID
* **COMMAND** = java → Process name

---

### **2. Using `netstat`**

`netstat` can show listening ports and the owning process.

```bash
sudo netstat -tulpn | grep :<port_number>
```

**Example:**

```bash
sudo netstat -tulpn | grep :8080
```

**Explanation of flags:**

* `-t` → TCP
* `-u` → UDP
* `-l` → Listening
* `-p` → Show PID/program name
* `-n` → Show numeric addresses (no DNS lookup)

---

### **3. Using `ss`** (modern replacement for `netstat`)

`ss` is faster and usually installed by default.

```bash
sudo ss -tulpn | grep :<port_number>
```

**Example:**

```bash
sudo ss -tulpn | grep :8080
```

**Output:**

```
LISTEN   0      50     *:8080    *:*    users:(("java",pid=1234,fd=45))
```

---

✅ **Tip:** If you only want the **PID**:

```bash
sudo lsof -ti :8080
```

This returns just the PID (1234) which you can then kill if needed:

```bash
sudo kill -9 1234
```

---

If you want, I can also show a **one-liner command that automatically kills the process listening on a port**—very handy for DevOps tasks.

Do you want me to show that?
